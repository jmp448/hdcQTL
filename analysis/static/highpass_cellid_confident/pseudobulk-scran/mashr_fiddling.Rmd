---
title: "mashR Evaluation"
output: html_notebook
---

```{r}
library(tidyverse)
library(mashr)
library(vroom)
```

## Overview of evaluation criteria
To evaluate model performance, we will train our `mashR` models on a subset of the tests (odd chromosomes) and evaluate on even chromosomes. 

## Germ layer-based covariance matrices

## Expression-driven covariance matrices
For expression-driven covariance matrices, I'll be decomposing the (normalized) pseudobulk expression data
```{r, fig.width=2, fig.height=2}
exp <- read_tsv("/project2/gilad/jpopp/ebQTL/data/static/highpass_cellid_confident/mashr/pseudobulk_per_celltype_hvg_normalized.tsv") %>%
  column_to_rownames("gene")

exp_svd <- svd(exp)

plot(exp_svd$d**2 / sum(exp_svd$d**2))
```

For pattern visualization, it'll be convenient to color cell types by their germ layer of origin
```{r}
germ_layer <- read_csv("/project2/gilad/katie/ebQTL/FetalReferenceCellTypes_GermLayerAnnotations.csv", col_select = -c(Notes)) %>%
  rename(celltype=`cell type`, layer=`Germ layer`) %>%
  group_by(celltype) %>% add_count() %>%
  mutate(layer=if_else(n > 1, "Ambiguous", layer)) %>%
  select(celltype, layer) %>%
  distinct() %>%
  mutate(layer=factor(layer, levels=c("Ambiguous", "Ectoderm", "Neural crest", "Endoderm", "Mesoderm")))

celltype_levels <- c("Ambiguous", "Ectoderm", "Neural crest", "Endoderm", "Mesoderm")
celltype_colors <- c("#D5D5D5", "#0076BA", "#006C65", "#FEAE00", "#A62228")
```
What patterns is PC1 picking up on?
```{r, height=4, width=1}
pcs <- tibble("celltype"=colnames(exp)) %>%
  left_join(germ_layer, by="celltype") %>%
  mutate(PC1=exp_svd$v[,1], PC2=exp_svd$v[,2]) 

pcs %>%
  ggplot(aes(x=celltype, y=PC1, fill=layer)) +
  geom_bar(stat="identity") +
  scale_fill_manual(values=celltype_colors) +
  coord_flip() +
  theme_classic()

pcs %>%
  ggplot(aes(x=celltype, y=PC2, fill=layer)) +
  geom_bar(stat="identity") +
  scale_fill_manual(values=celltype_colors) +
  coord_flip() +
  theme_classic()
```
Save covariance matrices
```{r}
u1 <- exp_svd$d[1] * (exp_svd$v[,1] %*% t(exp_svd$v[,1]))
u2 <- exp_svd$d[2] * (exp_svd$v[,2] %*% t(exp_svd$v[,2]))
u3 <- exp_svd$d[3] * (exp_svd$v[,3] %*% t(exp_svd$v[,3]))
u4 <- exp_svd$d[4] * (exp_svd$v[,4] %*% t(exp_svd$v[,4]))
u5 <- exp_svd$d[5] * (exp_svd$v[,5] %*% t(exp_svd$v[,5]))
ut <- u1 + u2 + u3 + u4 + u5

U.pca <- list(
  "PCA_1"= u1 / max(diag(u1)),
  "PCA_2"= u2 / max(diag(u2)), 
  "PCA_3"= u3 / max(diag(u3)),
  "PCA_4"= u4 / max(diag(u4)),
  "PCA_5"= u5 / max(diag(u5)),
  "tPCA" = ut / max(diag(ut))
)

saveRDS(U.pca, "/project2/gilad/jpopp/ebQTL/data/static/highpass_cellid_confident/mashr/expression.U.pca.rds")
```

## QTL-driven covariance matrices

## Model comparison
```{r}
# subset to snps that were kept for all analyses
qtls <- qtls %>%
  mutate(se=if_else(`t-stat`==0, as.double(NA), beta/`t-stat`), .after='beta') %>%
  mutate(se=if_else(se==0, as.double(NA), se)) %>%
  drop_na() %>%
  unite(gv, c(gene, SNP), sep="--", remove=FALSE)

keepers <- qtls %>%
  dplyr::count(gv) %>% 
  filter(n==length(qtl_files)) %>%
  pull(gv)

qtls <- qtls %>%
  filter(gv %in% keepers)
saveRDS(qtls, "/project2/gilad/jpopp/ebQTL/temp/qtls_combined.rds")

beta.hat <- qtls %>%
  select(gv, beta, type) %>%
  pivot_wider(names_from=type, values_from=beta, values_fill=NA) %>%
  column_to_rownames("gv") %>% as.matrix

se.hat <- qtls %>%
  select(gv, se, type) %>%
  pivot_wider(names_from=type, values_from=se, values_fill=NA) %>%
  column_to_rownames("gv") %>% as.matrix

df.hat <- qtls %>%
  select(gv, df, type) %>%
  pivot_wider(names_from=type, values_from=df, values_fill=NA) %>%
  column_to_rownames("gv") %>% as.matrix

top.hits <- qtls %>%
  select(gv, gene, `t-stat`, type) %>%
  mutate(`t-stat`=abs(`t-stat`)) %>%
  group_by(gene) %>%
  slice_max(`t-stat`, n=1, with_ties=FALSE) %>%
  pull(gv)
random.hits = sample(qtls$gv, min(250000, length(unique(qtls$gv))))

# estimate null correlation
data.temp = mash_set_data(beta.hat[random.hits,],se.hat[random.hits,])
Vhat = estimate_null_correlation_simple(data.temp)

data.random = mash_set_data(beta.hat[random.hits,], se.hat[random.hits,], V=Vhat, df=df.hat[random.hits,])
data.strong = mash_set_data(beta.hat[top.hits,], se.hat[top.hits,], V=Vhat, df=df.hat[top.hits,])
```

What do the existing mashR matrices look like? 
```{r}
m <- readRDS("results/mashr/pseudobulk/type/highpass_cellid_confident/eqtls/mashr.tophits.rds")
names(m$fitted_g$Ulist)
```

Here we've got 5 "ED PCA" matrices, one "ED tPCA" matrix, the identity matrix, specific effects for each context, equal effects, and simple het effects. What do the ED PC matrices look like?
```{r}
corrplot(m$fitted_g$Ulist$ED_PCA_1)
corrplot(m$fitted_g$Ulist$ED_PCA_2)
corrplot(m$fitted_g$Ulist$ED_PCA_3)
corrplot(m$fitted_g$Ulist$ED_PCA_4)
corrplot(m$fitted_g$Ulist$ED_PCA_5)
corrplot(m$fitted_g$Ulist$ED_tPCA)
```

Sooo that's a problem! How about those het ones?
```{r}
corrplot(m$fitted_g$Ulist$simple_het_1)
corrplot(m$fitted_g$Ulist$simple_het_2)
corrplot(m$fitted_g$Ulist$simple_het_3)
```

So these... all suck, no wonder we are not seeing interesting patterns. Looking under the hood, lets see if maybe we're running into some issues just from PCA
```{r}
U.pca = cov_pca(data.strong, 5)

corrplot(U.pca$PCA_1, is.corr=F)
corrplot(U.pca$PCA_2, is.corr=F)
corrplot(U.pca$PCA_3, is.corr=F)
corrplot(U.pca$PCA_4, is.corr=F)
corrplot(U.pca$PCA_5, is.corr=F)
corrplot(U.pca$tPCA, is.corr=F)
```

If we want to see the patterns coming out, we obviously need to have some patterns going in, and right now, we do not. 
```{r}
all_tophits <- qtls %>%
  select(gv, gene, `bonf.p`, type) %>%
  group_by(gene) %>%
  slice_min(`bonf.p`, n=1, with_ties=FALSE)
all_tophits$q <- qvalue(sighits$bonf.p)$qvalues

sighits <- all_tophits %>%
  filter(q<=0.05)

sig.hits <- pull(sighits, gv)
```

```{r}
data.stronger = mash_set_data(beta.hat[sig.hits,], se.hat[sig.hits,], V=Vhat, df=df.hat[sig.hits,])

U.pca.stronger = cov_pca(data.stronger, 5)

corrplot(U.pca.stronger$PCA_1, is.corr=F)
corrplot(U.pca.stronger$PCA_2, is.corr=F)
corrplot(U.pca.stronger$PCA_3, is.corr=F)
corrplot(U.pca.stronger$PCA_4, is.corr=F)
corrplot(U.pca.stronger$PCA_5, is.corr=F)
corrplot(U.pca.stronger$tPCA, is.corr=F)
```

Feed this into the ED algorithm
```{r}
U.ed.stronger = cov_ed(data.stronger, U.pca.stronger)

corrplot(U.pca.stronger$ED_PCA_1, is.corr=F)
corrplot(U.pca.stronger$ED_PCA_2, is.corr=F)
corrplot(U.pca.stronger$ED_PCA_3, is.corr=F)
corrplot(U.pca.stronger$ED_PCA_4, is.corr=F)
corrplot(U.pca.stronger$ED_PCA_5, is.corr=F)
corrplot(U.pca.stronger$ED_tPCA, is.corr=F)
```

We are maybe starting to get somewhere, but it's still not quite where we'd like it to be. Also worth noting that this is pretty similar to the original one.
```{r}
U.flash = cov_flash(data.stronger, remove_singleton=T)

corrplot(U.flash$tFLASH_default, is.corr=F)
corrplot(U.flash$FLASH_default_1, is.corr=F)
corrplot(U.flash$FLASH_default_2, is.corr=F)
corrplot(U.flash$FLASH_default_3, is.corr=F)
corrplot(U.flash$FLASH_default_4, is.corr=F)
corrplot(U.flash$FLASH_default_5, is.corr=F)
corrplot(U.flash$FLASH_default_6, is.corr=F)
corrplot(U.flash$FLASH_default_7, is.corr=F)
corrplot(U.flash$FLASH_default_8, is.corr=F)
corrplot(U.flash$FLASH_default_9, is.corr=F)
corrplot(U.flash$FLASH_default_10, is.corr=F)
```


