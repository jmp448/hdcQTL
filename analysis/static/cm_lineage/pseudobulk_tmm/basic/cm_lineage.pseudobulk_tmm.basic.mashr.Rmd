---
title: "Static and Context-Specific eQTL Calling with mashR"
output: html_notebook
---

```{r}
library(mashr)
library(corrplot)
library(tidyverse)
library(rmeta)
library(vroom)
library(RColorBrewer)
```


### eQTL detection with mashR

```{r}
m <- readRDS("/project2/gilad/jpopp/ebQTL/results/static/cm_lineage/pseudobulk_tmm/basic/4pcs/mashr.tophits.rds")
```

```{r, fig.width=6, fig.height=5}
n_qtl <- colSums(m$result$lfsr <= 0.05)

qtls_per_type_mashr <- tibble(type=names(n_qtl), n_eqtl=n_qtl)  %>% 
  arrange(n_qtl) %>%
  mutate(type=factor(type, levels=c("ipsc", "mesendo", "meso", "cp", "cm")))

ggplot(qtls_per_type_mashr, aes(x=type, y=n_eqtl)) +
  geom_segment( aes(x=type, xend=type, y=0, yend=n_eqtl), color="skyblue") +
  geom_point( color="blue", size=8, alpha=0.6) +
  theme_light(base_size=25) +
  coord_flip() +
  theme(
    panel.grid.major.y = element_blank(),
    panel.border = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  ylab("# Genes with eQTL") + xlab("Stage")
```

### Evaluating the correlation structure
```{r}
load("/project2/gilad/jpopp/ebQTL/results/static/cm_lineage/pseudobulk_tmm/basic/4pcs/mashr.training_data.RData")
corrplot(Vhat, tl.pos='l')
```

## Understanding Data-Driven Regulatory Patterns
```{r}
tibble(n_contexts=get_n_significant_conditions(m)) %>%
  filter(n_contexts >= 1) %>%
  dplyr::count(n_contexts, name="n_eqtl") %>%
  mutate(n_contexts=factor(n_contexts, levels=seq(1, ncol(m$result$lfsr)))) %>%
  ggplot(aes(x=n_contexts, y=n_eqtl)) +
  geom_bar(stat="identity") +
  theme_classic(base_size=15)
```

```{r}
tibble(n_contexts=get_n_significant_conditions(m)) %>%
  filter(n_contexts >= 1) %>%
  nrow(.)
```

Now, of the eQTLs that are specific to one context, which context is it?
```{r}
m$result$lfsr %>%
  as_tibble(rownames="gv") %>%
  pivot_longer(-gv, names_to="type", values_to="lfsr") %>%
  filter(lfsr<=0.05) %>%
  group_by(gv) %>%
  dplyr::select(-lfsr) %>%
  nest() %>%
  mutate(n_contexts=sapply(data, nrow)) %>%
  filter(n_contexts==1) %>%
  unnest(data) %>%
  mutate(type=factor(type, levels=c("ipsc", "mesendo", "meso", "cp", "cm"))) %>%
  group_by(type) %>%
  dplyr::count() %>%
  ggplot(aes(x=type, y=n, fill=type)) +
  geom_bar(stat="identity") +
  theme_classic() +
  ylab("# Singleton eQTLs") +
  theme(axis.text.x = element_text(angle = 45, hjust=1))
```


```{r}
singletons_per_type <- m$result$lfsr %>%
  as_tibble(rownames="gv") %>%
  pivot_longer(-gv, names_to="type", values_to="lfsr") %>%
  filter(lfsr<=0.05) %>%
  group_by(gv) %>%
  dplyr::select(-lfsr) %>%
  nest() %>%
  mutate(n_contexts=sapply(data, nrow)) %>%
  filter(n_contexts==1) %>%
  unnest(data) %>%
  mutate(type=factor(type)) %>%
  group_by(type) %>%
  dplyr::count()
singletons_per_type
```

Of the shared effects, how many contexts are they nominally significant in?
```{r}
all_qtls <- vroom(paste0("/project2/gilad/jpopp/ebQTL/results/static/cm_lineage/pseudobulk_tmm/basic/", c("ipsc", "mesendo", "meso", "cp", "cm"), "/4pcs/matrixeqtl.cis_qtl_pairs.tophits.tsv"), id="path") %>%
  mutate(type=map_chr(path, function(s){str_split(s, "/")[[1]][11]}), .keep="unused")

n_contexts_nominal <- all_qtls %>%
  filter(q<=0.05) %>%
  unite(gv, gene, SNP, sep="--") %>%
  group_by(gv) %>% count() %>%
  rename(n_nominal=n)

mash_shared <- as_tibble(get_n_significant_conditions(m), rownames="gv") %>%
  filter(value == 5)

n_contexts_nominal %>%
  filter(gv %in% mash_shared$gv) %>%
  ggplot(aes(x=n_nominal)) +
  geom_histogram()
```

### What are the strongest patterns?
How much weight does each covariance matrix receive?
```{r, fig.width=6, fig.height=8}
as_tibble(get_estimated_pi(m), rownames="component") %>%
  mutate(component=factor(component, levels=names(get_estimated_pi(m)))) %>%
  ggplot(aes(x=component, y=value)) +
  geom_bar(stat="identity") +
  scale_x_discrete(limits=rev) +
  xlab("Regulatory Pattern") +
  ylab("Weight") +
  coord_flip() +
  theme_classic(base_size = 20)
  #theme(axis.text.x = element_text(angle = 45, hjust=1))
```

How much weight is put on the data-driven covariance matrices as opposed to the canonical ones? In GTEx's implementation of mash, it was 80-20.
```{r}
as_tibble(get_estimated_pi(m), rownames="component") %>%
  mutate(category=if_else(str_sub(component, 1, 2)=="ED", "data-driven", "canonical")) %>%
  group_by(category) %>%
  summarize(contribution=sum(value))
```

```{r}
stage_colors <- brewer.pal(5, "Reds")
stage_levels <- c("ipsc", "mesendo", "meso", "cp", "cm")
```


Show more interesting covariance matrices
```{r}
m$fitted_g$Ulist$ED_PCA_1 %>%
  corrplot(is.corr=F, tl.pos='l')

pc1 <- m$fitted_g$Ulist$ED_PCA_1 %>%
  princomp %>%
  .$loadings %>%
  .[,1] %>%
  as_tibble(rownames="type") %>%
  mutate(type=factor(type, levels=stage_levels))
 
pc1 %>%
  ggplot(aes(x=type, y=value, fill=type)) +
  geom_bar(stat="identity") +
  coord_flip() +
  theme_classic() +
  scale_fill_manual(values=stage_colors) +
  ylab("PC1 Loading") + xlab("Cell Type")

m$fitted_g$Ulist$ED_PCA_2 %>%
  corrplot(is.corr=F, tl.pos='l')

pc2 <- m$fitted_g$Ulist$ED_PCA_2 %>%
  princomp %>%
  .$loadings %>%
  .[,1] %>%
  as_tibble(rownames="type") %>%
  mutate(type=factor(type, levels=stage_levels))
 
pc2 %>%
  ggplot(aes(x=type, y=value, fill=type)) +
  geom_bar(stat="identity") +
  coord_flip() +
  theme_classic() +
  scale_fill_manual(values=stage_colors) +
  ylab("PC2 Loading") + xlab("Cell Type")

m$fitted_g$Ulist$ED_PCA_3 %>%
  corrplot(is.corr=F, tl.pos='l')

pc3 <- m$fitted_g$Ulist$ED_PCA_3 %>%
  princomp %>%
  .$loadings %>%
  .[,1] %>%
  as_tibble(rownames="type") %>%
  mutate(type=factor(type, levels=stage_levels))
 
pc3 %>%
  ggplot(aes(x=type, y=value, fill=type)) +
  geom_bar(stat="identity") +
  coord_flip() +
  theme_classic() +
  scale_fill_manual(values=stage_colors) +
  ylab("PC3 Loading") + xlab("Cell Type")

m$fitted_g$Ulist$ED_PCA_4 %>%
  corrplot(is.corr=F, tl.pos='l')

pc4 <- m$fitted_g$Ulist$ED_PCA_4 %>%
  princomp %>%
  .$loadings %>%
  .[,1] %>%
  as_tibble(rownames="type") %>%
  mutate(type=factor(type, levels=stage_levels))
 
pc4 %>%
  ggplot(aes(x=type, y=value, fill=type)) +
  geom_bar(stat="identity") +
  coord_flip() +
  theme_classic() +
  scale_fill_manual(values=stage_colors) +
  ylab("PC4 Loading") + xlab("Cell Type")
```

```{r}
both_pcs <- pc1 %>%
  mutate(component="PC1") %>%
  bind_rows(mutate(pc2, component="PC2")) %>%
  rename(`Germ Layer`=layer)

fig <- both_pcs %>% 
  ggplot(aes(x=celltype, y=value, fill=`Germ Layer`)) +
  facet_grid(cols=vars(component)) +
  geom_bar(stat="identity") +
  scale_fill_manual(values=germlayer_colors) +
  coord_flip() +
  theme_classic(base_size = 40) +
  ylab("Loading") + xlab("Cell Type")

png("/project2/gilad/jpopp/ebQTL/temp/components.png", width=3000, height=1600)
plot(fig)
dev.off()
```

## Examining Context-Specific eQTLs
Find any significant eQTLs whose effects are best explained by those signals, starting with component 1 (which is highest in IPSC, lower elsewhere)
```{r}
tests <- rownames(get_lfsr(m))
sighits <- get_significant_results(m)
component_per_hit <- as_tibble(m$posterior_weights) %>%
  rowid_to_column() %>%
  filter(rowid %in% sighits) %>%
  pivot_longer(-rowid, names_to="component", values_to="weight") %>%
  mutate(component=str_extract(component, "[^.]+")) %>%
  group_by(rowid, component) %>%
  summarize(contribution=sum(weight)) %>%
  slice_max(contribution) %>%
  arrange(desc(contribution))

post_weights_cov_scale = m$posterior_weights
colnames(post_weights_cov_scale) = do.call(rbind, str_split(colnames(post_weights_cov_scale), '\\.'))[,1]
post_weights_cov= t(rowsum(t(post_weights_cov_scale), colnames(post_weights_cov_scale)))

pc1_driven_tests <- component_per_hit %>%
  filter(component=="ED_PCA_1") %>%
  pull(rowid)

mash_plot_meta(m, pc1_driven_tests[1], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc1_driven_tests[2], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc1_driven_tests[3], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc1_driven_tests[4], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc1_driven_tests[5], colors=meta.colors(box=stage_colors))
```

```{r}
pc2_driven_tests <- component_per_hit %>%
  filter(component=="ED_PCA_2") %>%
  pull(rowid)

mash_plot_meta(m, pc2_driven_tests[1], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc2_driven_tests[2], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc2_driven_tests[3], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc2_driven_tests[4], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc2_driven_tests[5], colors=meta.colors(box=stage_colors))
```

```{r}
pc3_driven_tests <- as_tibble(m$posterior_weights) %>%
  rowid_to_column() %>%
  filter(rowid %in% sighits) %>%
  pivot_longer(-rowid, names_to="component", values_to="weight") %>%
  group_by(rowid) %>%
  slice_max(weight) %>%
  mutate(component=str_extract(component, "[^.]+")) %>%
  filter(component=="ED_PCA_3") %>%
  pull(rowid)

mash_plot_meta(m, pc3_driven_tests[1], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc3_driven_tests[2], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc3_driven_tests[3], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc3_driven_tests[4], colors=meta.colors(box=stage_colors))
mash_plot_meta(m, pc3_driven_tests[5], colors=meta.colors(box=stage_colors))
```

